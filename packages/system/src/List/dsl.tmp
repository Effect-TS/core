/**
 * Alias for [`foldl`](#foldl).
 *
 * @category Folds
 */
export const reduce = foldl

export interface Of {
  "fantasy-land/of"<B>(a: B): Applicative<B>
}

export interface Applicative<A> {
  "fantasy-land/map"<B>(f: (a: A) => B): Applicative<B>
  "fantasy-land/ap"<B>(fa: Applicative<(a: A) => B>): Applicative<B>
}

/**
 * Map each element of list to an applicative, evaluate these
 * applicatives from left to right, and collect the results.
 *
 * This works with Fantasy Land
 * [applicatives](https://github.com/fantasyland/fantasy-land#applicative).
 *
 * @category Folds
 * @example
 * const l = list(1, 3, 5, 4, 2);
 * L.scan((n, m) => n + m, 0, l); //=> list(0, 1, 4, 9, 13, 15));
 * L.scan((s, m) => s + m.toString(), "", l); //=> list("", "1", "13", "135", "1354", "13542")
 */
export function traverse<A, B>(of: Of, f: (a: A) => Applicative<B>, l: List<A>): any {
  return foldr(
    (a, fl) =>
      fl["fantasy-land/ap"](
        f(a)["fantasy-land/map"]((a) => (l: List<any>) => prepend(a, l))
      ),
    of["fantasy-land/of"](empty()),
    l
  )
}

/**
 * Evaluate each applicative in the list from left to right, and and
 * collect the results.
 *
 * @complexity O(n)
 * @category Folds
 * @example
 * L.sequence(Maybe, list(just(1), just(2), just(3))); //=> just(list(1, 2, 3))
 * L.sequence(Maybe, list(just(1), just(2), nothing())); //=> nothing
 */
export function sequence<A>(ofObj: Of, l: List<Applicative<A>>): any {
  return traverse(ofObj, (a) => a, l)
}

export interface Ord {
  "fantasy-land/lte"(b: any): boolean
}

export type Comparable = number | string | Ord

const ord = "fantasy-land/lte"

function compareOrd(a: Ord, b: Ord): Ordering {
  return a[ord](b) ? (b[ord](a) ? 0 : -1) : 1
}

/**
 * Sorts the given list. The list should contain values that can be
 * compared using the `<` operator or values that implement the
 * Fantasy Land [Ord](https://github.com/fantasyland/fantasy-land#ord)
 * specification.
 *
 * Performs a stable sort.
 *
 * @complexity O(n * log(n))
 * @category Transformers
 * @example
 * sort(list(5, 3, 1, 8, 2)); //=> list(1, 2, 3, 5, 8)
 * sort(list("e", "a", "c", "b", "d"); //=> list("a", "b", "c", "d", "e")
 */
export function sort<A extends Comparable>(l: List<A>): List<A> {
  if (l.length === 0) {
    return l
  } else if (isPrimitive(first(l))) {
    return from(toArray(l).sort(comparePrimitive as any))
  } else {
    return sortWith(compareOrd, l as any) as any
  }
}

/**
 * Sort the given list by passing each value through the function and
 * comparing the resulting value. The function should either return
 * values comparable using `<` or values that implement the Fantasy
 * Land [Ord](https://github.com/fantasyland/fantasy-land#ord)
 * specification.
 *
 * Performs a stable sort.
 *
 * @complexity O(n * log(n))
 * @category Transformers
 * @example
 *
 * sortBy(
 *   o => o.n,
 *   list({ n: 4, m: "foo" }, { n: 3, m: "bar" }, { n: 1, m: "baz" })
 * ); //=> list({ n: 1, m: "baz" }, { n: 3, m: "bar" }, { n: 4, m: "foo" })
 *
 * sortBy(s => s.length, list("foo", "bar", "ba", "aa", "list", "z"));
 * //=> list("z", "ba", "aa", "foo", "bar", "list")
 */
export function sortBy<A, B extends Comparable>(f: (a: A) => B, l: List<A>): List<A> {
  if (l.length === 0) {
    return l
  }
  const arr: { elm: A; prop: B; idx: number }[] = []
  let i = 0
  forEach((elm) => arr.push({ idx: i++, elm, prop: f(elm) }), l)
  const comparator: any = isPrimitive(arr[0].prop) ? comparePrimitive : compareOrd
  arr.sort(({ idx: i, prop: a }, { idx: j, prop: b }) => {
    const c = comparator(a, b)
    return c !== 0 ? c : i < j ? -1 : 1
  })
  const newL = emptyPushable<A>()
  for (let i = 0; i < arr.length; ++i) {
    push(arr[i].elm, newL)
  }
  return newL
}

function isPrimitive(value: any): value is number | string {
  return typeof value === "number" || typeof value === "string"
}

function comparePrimitive<A extends number | string>(a: A, b: A): Ordering {
  return a === b ? 0 : a < b ? -1 : 1
}